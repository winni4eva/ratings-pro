{"version":3,"sources":["shared/file-generator/file.service.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;YAOA;gBAIE,qBACsB,IAAU,EACV,QAAwB;oBADxB,SAAI,GAAJ,IAAI,CAAM;oBACV,aAAQ,GAAR,QAAQ,CAAgB;oBAJtC,YAAO,GAAG,eAAe,CAAC;gBAIe,CAAC;gBAGlD,8BAAQ,GAAR,UAAS,QAAgB,EAAE,QAAQ;oBAE/B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAE,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,SAAS,CAAE,EAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAC,CAAE,CAAE;yBAChF,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC;yBACrB,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAE7C,CAAC;gBAED,iCAAW,GAAX,UAAY,IAAS,EAAE,QAAQ;oBAEzB,IAAI,cAAc,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAA,gCAAgC;oBAEhE,IAAI,WAAW,GAAG,IAAI,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;oBAEnD,IAAI,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC;oBAEnC;;;;sBAIE;oBACF,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;wBAC9B,WAAW,CAAC,CAAC,CAAC,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBAClD,CAAC;oBACD,IAAI,SAAS,GAAG,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC,CAAA,2DAA2D;oBAEvG,EAAE,CAAA,CAAC,QAAQ,IAAI,KAAK,CAAC,CAAC,CAAC;wBACnB,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,IAAI,EAAE,iBAAiB,EAAE,CAAC,CAAC;oBAClE,CAAC;oBAAA,IAAI,CAAC,EAAE,CAAA,CAAC,QAAQ,IAAI,OAAO,CAAC,CAAA,CAAC;wBAC1B,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,CAAC,SAAS,CAAC,EAAE,EAAE,IAAI,EAAE,0BAA0B,EAAE,CAAC,CAAC;oBAC3E,CAAC;oBAED,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;gBAE5C,CAAC;gBAEK,iCAAW,GAAnB,UAAoB,GAAa;oBAC7B,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAG,CAAC;gBAC7B,CAAC;gBAEO,iCAAW,GAAnB,UAAqB,KAAU;oBAE3B,IAAI,MAAM,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,KAAK,CAAC,OAAO;wBAC1C,KAAK,CAAC,MAAM,GAAM,KAAK,CAAC,MAAM,WAAM,KAAK,CAAC,UAAY,GAAG,cAAc,CAAC;oBAE1E,MAAM,CAAC,uBAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;gBAEpC,CAAC;gBAzDH;oBAAC,iBAAU,EAAE;;+BAAA;gBA2Db,kBAAC;YAAD,CA1DA,AA0DC,IAAA;YA1DD,qCA0DC,CAAA","file":"shared/file-generator/file.service.js","sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Http, Headers, Response, RequestOptions } from '@angular/http';\r\nimport { Observable } from 'rxjs/Observable';\r\nimport 'rxjs/Rx';\r\nimport { StorageService } from '../../shared/storage/storage.service'; \r\n\r\n@Injectable()\r\nexport class FileService {\r\n  \r\n  private _apiUrl = '/api/v1/files';\r\n\r\n  constructor(\r\n                private http: Http,\r\n                private _storage: StorageService) {}\r\n\r\n\r\n  generate(resource: string, fileType): Observable<any>{\r\n      \r\n      return this.http.post( this._apiUrl, JSON.stringify( {resource: resource, fileType: fileType} ) )\r\n                      .map(this.extractData)\r\n                      .catch(this.handleError);\r\n      \r\n  }\r\n\r\n  printReport(data: any, fileType){\r\n\r\n        let byteCharacters = atob(data);//decode a base64-encoded string\r\n\r\n        let byteNumbers = new Array(byteCharacters.length);\r\n\r\n        let length = byteCharacters.length;\r\n\r\n        /*\r\n            Each character's code point (charCode) will be the value of the byte. \r\n            We can create an array of byte values by applying this using the .\r\n            charCodeAt method for each character in the string.\r\n        */\r\n        for (let i = 0; i < length; i++) {\r\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n        }\r\n        let byteArray = new Uint8Array(byteNumbers);//Convert array of byte values into a real typed byte array\r\n\r\n        if(fileType == 'pdf') {\r\n            var blob = new Blob([byteArray], { type: 'application/pdf' });\r\n        }else if(fileType == 'excel'){\r\n            var blob = new Blob([byteArray], { type: 'application/vnd.ms-excel' });\r\n        }\r\n\r\n        return window.URL.createObjectURL(blob);\r\n\r\n    }\r\n\r\n  private extractData(res: Response) {\r\n      return res.json() || { };\r\n  }\r\n\r\n  private handleError (error: any) {\r\n      \r\n      let errMsg = (error.message) ? error.message :\r\n        error.status ? `${error.status} - ${error.statusText}` : 'Server error';\r\n\r\n      return Observable.throw(errMsg);\r\n\r\n  }\r\n\r\n}\r\n"],"sourceRoot":"/source/"}